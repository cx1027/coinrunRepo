,scene = list(xaxis = list(title = "Delta Reward"),
yaxis = list(title = "Selected Reward"),
zaxis = list(title = "Weight"))
)
library(plotly)
packageVersion('plotly')
mycolors=gray(2:10/10)
unique(data_p1$weight)
data<-read.csv(file='/Users/X/Documents/R_data/data_MOXCS2018/3d_plot/maze5_3d_s3_0129.csv',header = T,sep=",")#maze5
data_p1 <- data%>%filter(data$OpenState == "s3" )
plot_ly(data_p1, x = ~Q_finalreward_delta.1, y = ~Q_finalreward_select.1, z = ~weight, type = 'scatter3d', mode = 'lines',
color = ~weight, colors = mycolors)%>%
layout(title = 'Weights VS Delta Predicition VS Selected Predction on s3 in Maze5'
,scene = list(xaxis = list(title = "Delta Reward"),
yaxis = list(title = "Selected Reward"),
zaxis = list(title = "Weight"))
)
library(plotly)
packageVersion('plotly')
mycolors=gray(0:10/10)
unique(data_p1$weight)
data<-read.csv(file='/Users/X/Documents/R_data/data_MOXCS2018/3d_plot/maze5_3d_s3_0129.csv',header = T,sep=",")#maze5
data_p1 <- data%>%filter(data$OpenState == "s3" )
plot_ly(data_p1, x = ~Q_finalreward_delta.1, y = ~Q_finalreward_select.1, z = ~weight, type = 'scatter3d', mode = 'lines',
color = ~weight, colors = mycolors)%>%
layout(title = 'Weights VS Delta Predicition VS Selected Predction on s3 in Maze5'
,scene = list(xaxis = list(title = "Delta Reward"),
yaxis = list(title = "Selected Reward"),
zaxis = list(title = "Weight"))
)
plot_ly(data_p2, x = ~Q_finalreward_delta.1, y = ~Q_finalreward_select.1, z = ~weight, type = 'scatter3d', mode = 'lines',
color = ~weight, colors = mycolors)%>%
layout(title = 'Weights VS Delta Predicition VS Selected Predction on s10 in Maze4'
,scene = list(xaxis = list(title = "Delta Reward"),
yaxis = list(title = "      Selected Reward"),
zaxis = list(title = "Weight"))
)
mycolors=gray(0:10/10)
unique(data_p1$weight)
data<-read.csv(file='/Users/X/Documents/R_data/data_MOXCS2018/3d_plot/maze5_3d_s3_0129.csv',header = T,sep=",")#maze5
data_p1 <- data%>%filter(data$OpenState == "s3" )
plot_ly(data_p1, x = ~Q_finalreward_delta.1, y = ~Q_finalreward_select.1, z = ~weight, type = 'scatter3d', mode = 'lines',
color = ~weight, colors = mycolors)%>%
layout(title = 'Weights VS Delta Predicition VS Selected Predction on s3 in Maze5'
,scene = list(xaxis = list(title = "Delta Reward"),
yaxis = list(title = "       Selected Reward"),
zaxis = list(title = "Weight"))
)
mycolors=gray(0:10/10)
unique(data_p1$weight)
data<-read.csv(file='/Users/X/Documents/R_data/data_MOXCS2018/3d_plot/maze5_3d_s3_0129.csv',header = T,sep=",")#maze5
data_p1 <- data%>%filter(data$OpenState == "s3" )
plot_ly(data_p1, x = ~Q_finalreward_delta.1, y = ~Q_finalreward_select.1, z = ~weight, type = 'scatter3d', mode = 'lines',
color = ~weight, colors = mycolors)%>%
layout(title = 'Weights VS Delta Predicition VS Selected Predction on s3 in Maze5'
,scene = list(xaxis = list(title = "Delta Reward"),
yaxis = list(title = "          Selected Reward"),
zaxis = list(title = "Weight"))
)
data_p3<-read.csv(file='/Users/X/Documents/R_data/data_MOXCS2018/3d_plot/s6_22_finalselect.csv',header = T,sep=",")#maze6
#data_p3 <- data_p3%>%filter(data_p3$weight == "0.000000|1.000000" )
plot_ly(data_p3, x = ~Q_finalreward_delta.1, y = ~Q_finalreward_select.1, z = ~weight, type = 'scatter3d', mode = 'lines',
color = ~weight, colors = mycolors)%>%
layout(title = 'Weights VS Delta Predicition VS Selected Predction on s13 in Maze6'
,scene = list(xaxis = list(title = "Delta Reward"),
yaxis = list(title = "      Selected Reward"),
zaxis = list(title = "Weight"))
)
install.packages("TraMineR")
library("TraMineR")
install.packages("TraMineR")
install.packages("TraMineR")
install.packages("TraMineR")
install.packages("TraMineR")
library("TraMineR")
data(mvad)
install.packages("TraMineR")
library("TraMineR")
data(mvad)
install.packages("TraMineR")
install.packages("TraMineR")
install.packages("TraMineR")
library("TraMineR")
install.packages("TraMineR")
library("TraMineR")
data("mvad")
summary("mvad")
data(mvad)
summary(mvad)
myseq<-seqdef(mvad,17:86)
seqiplot(myseq)
seqfplot(myseq)
seqdplot(myseq)
seqHtplot(myseq)
myturbulence<-seqST(myseq)
hist(myturbulence)
summary(mvad)
summary(mvad)
seqiplot(myseq)
seqfplot(myseq)
seqdplot(myseq)
library("TraMineR")
data(mvad)
data[1:4,]
data(mvad)
summary(mvad)
myseq<-seqdef(mvad,17:86)
myseq[1:4,]
seqHtplot(myseq)
myturbulence<-seqST(myseq)
View(myturbulence)
hist(myturbulence)
seqdplot(mvad.seq, group=pamclustfac, border=NA)
seqdplot(myseq, group=pamclustfac, border=NA)
seqdplot(myseq, border=NA)
seqdplot(myseq, group=mvad$funemp, border=NA)
funemp_assoc <- dissassoc(mvad.dist, mvad$funemp, R = 5000)
funemp_assoc <- dissassoc(mvad.dist, mvad$funemp, R = 5000)
mvad.id
mvad[dist]
mvad.dist
mvad.dist <- seqdist(mvad.seq, method="HAM", sm="CONSTANT")
st <- seqtree(myseq ~ gcse5eq + Grammar + funemp + sex,
+ data = mvad, R = 5000, diss = mvad.dist)
seqtreedisplay(st, type = "d", border = NA)
mvad.dist <- seqdist(mvad.seq, method="HAM", sm="CONSTANT")
mvad.dist <- seqdist(myseq, method="HAM", sm="CONSTANT")
st <- seqtree(myseq ~ gcse5eq + Grammar + funemp + sex,
data = mvad, R = 5000, diss = mvad.dist)
st <- seqtree(myseq ~ gcse5eq + Grammar + funemp + sex,
+data = mvad, R = 5000, diss = mvad.dist)
st <- seqtree(myseq ~ gcse5eq + Grammar + funemp + male,
+data = mvad, R = 5000, diss = mvad.dist)
st <- seqtree(myseq ~ gcse5eq + Grammar + funemp + male,
data = mvad, R = 5000, diss = mvad.dist)
seqtreedisplay(st, type = "d", border = NA)
seqtreedisplay(st, type = "d", border = NA)
## Clustering
wardCluster <- hclust(as.dist(mvad.dist), method = "ward", members = mvad$weight)
library(TraMineR)
library(WeightedCluster)
data(mvad)
mvad.alphabet <- c("employment", "FE", "HE", "joblessness", "school", "training")
mvad.labels <- c("Employment", "Further Education", "Higher Education", "Joblessness", "School", "Training")
mvad.scodes <- c("EM", "FE", "HE", "JL", "SC", "TR")
## Define sequence objects
mvad.seq <- seqdef(mvad[, 17:86], alphabet = mvad.alphabet, states = mvad.scodes, labels = mvad.labels, weights = mvad$weight, xtstep = 6)
## Computing OM dissimilarities
mvad.dist <- seqdist(mvad.seq, method="HAM", sm="CONSTANT")
## Clustering
wardCluster <- hclust(as.dist(mvad.dist), method = "ward", members = mvad$weight)
clust4 <- cutree(wardCluster, k = 4)
## Silhouettes
sil <- wcSilhouetteObs(mvad.dist, clust4, weights = mvad$weight, measure = "ASWw")
## Sequence index plots ordered by representativeness
seqIplot(mvad.seq, group = clust4, sortv = sil)
seqIplot(mvad.seq, group = clust4)
cl4.lab <- factor(mvad.cl4, labels = paste("Cluster", 1:4))
library(TraMineR)
data(mvad)
#format data
mvad.alphab <- c("employment", "FE", "HE", "joblessness","school", "training")
mvad.seq <- seqdef(mvad, 17:86, xtstep = 6, alphabet = mvad.alphab)
#compute distance
mvad.om <- seqdist(mvad.seq, method = "OM", indel = 1, sm = "TRATE")
#clustering
library("cluster")
clusterward <- agnes(mvad.om, diss = TRUE, method = "ward")
mvad.cl4 <- cutree(clusterward, k = 4)
cl4.lab <- factor(mvad.cl4, labels = paste("Cluster", 1:4))
seqdplot(mvad.seq, group = cl4.lab, border = NA)
#compute distance
mvad.om <- seqdist(mvad.seq, method = "OM", indel = 1, sm = "TRATE")
library(TraMineR)
data(mvad)
#format data
mvad.alphab <- c("employment", "FE", "HE", "joblessness","school", "training")
mvad.seq <- seqdef(mvad, 17:86, xtstep = 6, alphabet = mvad.alphab)
#compute distance
mvad.om <- seqdist(mvad.seq, method = "OM", indel = 1, sm = "TRATE")
#clustering
library("cluster")
clusterward <- agnes(mvad.om, diss = TRUE, method = "ward")
mvad.cl4 <- cutree(clusterward, k = 4)
cl4.lab <- factor(mvad.cl4, labels = paste("Cluster", 1:4))
#visualize
seqdplot(mvad.seq, group = cl4.lab, border = NA)
dev.off()
seqdplot(mvad.seq, group = cl4.lab, border = NA)
library(TraMineR)
data(mvad)
#format data
mvad.alphab <- c("employment", "FE", "HE", "joblessness","school", "training")
mvad.seq <- seqdef(mvad, 17:86, xtstep = 6, alphabet = mvad.alphab)
#compute distance
mvad.om <- seqdist(mvad.seq, method = "OM", indel = 1, sm = "TRATE")
#clustering
library("cluster")
clusterward <- agnes(mvad.om, diss = TRUE, method = "ward")
mvad.cl4 <- cutree(clusterward, k = 4)
cl4.lab <- factor(mvad.cl4, labels = paste("Cluster", 1:4))
#visualize
dev.off()
seqdplot(mvad.seq, group = cl4.lab, border = NA)
library(TraMineR)
data(mvad)
#format data
mvad.alphab <- c("employment", "FE", "HE", "joblessness","school", "training")
mvad.seq <- seqdef(mvad, 17:86, xtstep = 6, alphabet = mvad.alphab)
#compute distance
mvad.om <- seqdist(mvad.seq, method = "OM", indel = 1, sm = "TRATE")
#clustering
library("cluster")
clusterward <- agnes(mvad.om, diss = TRUE, method = "ward")
mvad.cl4 <- cutree(clusterward, k = 4)
cl4.lab <- factor(mvad.cl4, labels = paste("Cluster", 1:4))
#visualize
dev.off()
graphics.off()
seqdplot(mvad.seq, group = cl4.lab, border = NA)
entropies <- seqient(mvad.seq)
entropies <- seqient(mvad.seq)
lm.ent <- lm(entropies ~ male + funemp + gcse5eq, mvad)
seqmtplot(mvad.seq, group = mvad$funemp, ylim = c(0, 30))
mvad.trate <- seqtrate(mvad.seq)
round(mvad.trate, 2)
mvad.trate <- seqtrate(mvad.seq)
round(mvad.trate, 2)
mvad.dist <- seqdist(myseq, method="HAM", sm="CONSTANT")
st <- seqtree(myseq ~ gcse5eq + Grammar + funemp + male,
data = mvad, R = 5000, diss = mvad.dist)
seqtreedisplay(st, type = "d", border = NA)
print(st)
lm.ent
saveHTML({
for (y in unique(population$year)) {
pop_year <- subset(population, year==y & age %in% ages)
female <- pop_year$female_pct
male <- pop_year$male_pct
par(cex=0.8)
par(mar=pyramid.plot(male, female, top.labels=c("Male", "", "Female"), labels=ages, main=y, lxcol="#A097CC", rxcol="#EDBFBE", xlim=c(10,10), gap=0, unit=""))
}
}, htmlfile = "population-pyramid-animated.html", interval=0.15, nmax=100, ani.width=650, ani.height=400)
library(animation)
# Load the data. Source: US Census Bureau
population <- read.csv("data/us-pop-age-sex.csv", stringsAsFactors=FALSE)
#
# Pyramid chart for one year, using plotrix package
#
library(plotrix)
# Subset on age and sex
ages <- unique(population$age)[-1]  # Won't chart the total
pop2015 <- subset(population, year==2015 & age %in% ages)
female <- pop2015$female_pct
male <- pop2015$male_pct
# Draw the plot
pyramid.plot(male, female, labels=ages, main="US Population 2015")
# Simplified
par(cex=0.85)
par(mar=pyramid.plot(male, female, labels=ages, main="Population Percentages by Age and Sex, 2015", lxcol="#A097CC", rxcol="#EDBFBE", unit="", xlim=c(10,10), gap=0))
# Plot for every year.
par(mfrow=c(4,4))
for (y in unique(population$year)) {
pop_year <- subset(population, year==y & age %in% ages)
female <- pop_year$female_pct
male <- pop_year$male_pct
par(cex=0.6)
par(mar=pyramid.plot(male, female, top.labels=c("Male", "", "Female"), labels=ages, main=y, lxcol="#A097CC", rxcol="#EDBFBE", xlim=c(10,10), gap=0, unit=""))
}
#
# Animate
#
ani.options(outdir = paste(getwd(), "/images", sep=""))
saveGIF({
for (y in unique(population$year)) {
pop_year <- subset(population, year==y & age %in% ages)
female <- pop_year$female_pct
male <- pop_year$male_pct
par(cex=0.8)
par(mar=pyramid.plot(male, female, top.labels=c("Male", "", "Female"), labels=ages, main=y, lxcol="#A097CC", rxcol="#EDBFBE", xlim=c(10,10), gap=0, unit=""))
}
}, movie.name = "population-pyramid-animated.gif", interval=0.15, nmax=100, ani.width=650, ani.height=400)
saveHTML({
for (y in unique(population$year)) {
pop_year <- subset(population, year==y & age %in% ages)
female <- pop_year$female_pct
male <- pop_year$male_pct
par(cex=0.8)
par(mar=pyramid.plot(male, female, top.labels=c("Male", "", "Female"), labels=ages, main=y, lxcol="#A097CC", rxcol="#EDBFBE", xlim=c(10,10), gap=0, unit=""))
}
}, htmlfile = "population-pyramid-animated.html", interval=0.15, nmax=100, ani.width=650, ani.height=400)
library(animation)
# Load the data. Source: US Census Bureau
population <- read.csv("data/us-pop-age-sex.csv", stringsAsFactors=FALSE)
library(animation)
# Load the data. Source: US Census Bureau
population <- read.csv("data/us-pop-age-sex.csv", stringsAsFactors=FALSE)
#
# Pyramid chart for one year, using plotrix package
#
library(plotrix)
# Subset on age and sex
ages <- unique(population$age)[-1]  # Won't chart the total
pop2015 <- subset(population, year==2015 & age %in% ages)
female <- pop2015$female_pct
male <- pop2015$male_pct
population <- read.csv("data/us-pop-age-sex.csv", stringsAsFactors=FALSE)
population <- read.csv("us-pop-age-sex.csv", stringsAsFactors=FALSE)
library(animation)
population <- read.csv("data/us-pop-age-sex.csv", stringsAsFactors=FALSE)
install.packages("animation", dependencies = TRUE)
library(animation)
library(animation)
install.packages("ImageMagick")
library(latticeExtra)
R version
R --version
version
R.version()
.version()
R.Version()
df_reward_sub<-subset(data, select=c(obj_r1,states,Q_finalreward_delta,Q_finalreward_max))
library(ggplot2)
#data is ordered by value rather than the p order
data<-read.csv(file="/Users/X/Documents/R_data/data_MOXCS2018/s6_22.csv")
df_reward_sub<-subset(data, select=c(obj_r1,states,Q_finalreward_delta,Q_finalreward_max))
levels(df_reward_sub$obj_r1) = c('20', '30', '40', '50','60','70','80','90','100','110')
(p3 <- ggplot(data=df_reward_sub, aes(x = Q_finalreward_delta, y = Q_finalreward_max, colour = states)) +
geom_line() + geom_point() +
labs(y="Maximal PA of Reward",
x="Difference of PA for F_1 and F_2",
title="Influence of Reward Settings on Action Selection in maze6")
)
if ("package:h2o" %in% search()) { detach("package:h2o", unload=TRUE) }
if ("h2o" %in% rownames(installed.packages())) { remove.packages("h2o") }
if (! ("methods" %in% rownames(installed.packages()))) { install.packages("methods") }
if (! ("statmod" %in% rownames(installed.packages()))) { install.packages("statmod") }
if (! ("stats" %in% rownames(installed.packages()))) { install.packages("stats") }
if (! ("graphics" %in% rownames(installed.packages()))) { install.packages("graphics") }
if (! ("RCurl" %in% rownames(installed.packages()))) { install.packages("RCurl") }
library(updateR)
install.packages(updateR)
install.packages('updateR')
install.packages('updateR')
install.packages('updater')
install.packages("installr");
install.packages("installr")
if ("package:h2o" %in% search()) { detach("package:h2o", unload=TRUE) }
if ("h2o" %in% rownames(installed.packages())) { remove.packages("h2o") }
if (! ("methods" %in% rownames(installed.packages()))) { install.packages("methods") }
if (! ("statmod" %in% rownames(installed.packages()))) { install.packages("statmod") }
if (! ("stats" %in% rownames(installed.packages()))) { install.packages("stats") }
if (! ("graphics" %in% rownames(installed.packages()))) { install.packages("graphics") }
if (! ("RCurl" %in% rownames(installed.packages()))) { install.packages("RCurl") }
if (! ("jsonlite" %in% rownames(installed.packages()))) { install.packages("jsonlite") }
if (! ("tools" %in% rownames(installed.packages()))) { install.packages("tools") }
if (! ("utils" %in% rownames(installed.packages()))) { install.packages("utils") }
install.packages("h2o", type="source", repos=(c("http://h2o-release.s3.amazonaws.com/h2o/rel-tibshirani/2/R")))
library(h2o)
localH2O = h2o.init(nthreads=-1)
demo(h2o.kmeans)
print("Import approved and rejected loan requests...")
## Set your working directory
# setwd("/Users/tomk/0xdata/ws/app-consumer-loan")
library(h2o)
h2o.init(nthreads = -1)
print("Import approved and rejected loan requests...")
loans  <- h2o.importFile(path = "data/loan.csv")
loans$bad_loan <- as.factor(loans$bad_loan)
rand  <- h2o.runif(loans, seed = 1234567)
train <- loans[rand$rnd <= 0.8, ]
valid <- loans[rand$rnd > 0.8, ]
myY = "bad_loan"
myX = c("loan_amnt", "longest_credit_length", "revol_util", "emp_length",
"home_ownership", "annual_inc", "purpose", "addr_state", "dti",
"delinq_2yrs", "total_acc", "verification_status", "term")
model <- h2o.gbm(x = myX, y = myY,
training_frame = train, validation_frame = valid,
score_each_iteration = T,
ntrees = 100, max_depth = 5, learn_rate = 0.05,
model_id = "BadLoanModel")
print(model)
# Download generated POJO for model
if (! file.exists("tmp")) {
dir.create("tmp")
}
h2o.download_pojo(model, path = "tmp")
myY = "int_rate"
myX = c("loan_amnt", "longest_credit_length", "revol_util", "emp_length",
"home_ownership", "annual_inc", "purpose", "addr_state", "dti",
"delinq_2yrs", "total_acc", "verification_status", "term")
model <- h2o.gbm(x = myX, y = myY,
training_frame = train, validation_frame = valid,
score_each_iteration = T,
ntrees = 100, max_depth = 5, learn_rate = 0.05,
model_id = "InterestRateModel")
print(model)
# Download generated POJO for model
if (! file.exists("tmp")) {
dir.create("tmp")
}
h2o.download_pojo(model, path = "tmp")
h2o.download_pojo(model, path = "tmp")
print(model)
cls
library(h2o)
h2o.init(nthreads = -1)
print("Import approved and rejected loan requests...")
loans  <- h2o.importFile(path = "data/loan.csv")
loans$bad_loan <- as.factor(loans$bad_loan)
rand  <- h2o.runif(loans, seed = 1234567)
train <- loans[rand$rnd <= 0.8, ]
valid <- loans[rand$rnd > 0.8, ]
library(h2o)
h2o.init(nthreads = -1)
print("Import approved and rejected loan requests...")
loans  <- h2o.importFile(path = "data/loan.csv")
loans  <- h2o.importFile(path = "/Users/X/git/modelDeployment/app-consumer-loan-master/data/loan.csv")
loans$bad_loan <- as.factor(loans$bad_loan)
rand  <- h2o.runif(loans, seed = 1234567)
train <- loans[rand$rnd <= 0.8, ]
valid <- loans[rand$rnd > 0.8, ]
myY = "bad_loan"
myX = c("loan_amnt", "longest_credit_length", "revol_util", "emp_length",
"home_ownership", "annual_inc", "purpose", "addr_state", "dti",
"delinq_2yrs", "total_acc", "verification_status", "term")
model <- h2o.gbm(x = myX, y = myY,
training_frame = train, validation_frame = valid,
score_each_iteration = T,
ntrees = 100, max_depth = 5, learn_rate = 0.05,
model_id = "BadLoanModel")
print(model)
# Download generated POJO for model
if (! file.exists("tmp")) {
dir.create("tmp")
}
h2o.download_pojo(model, path = "tmp")
myY = "int_rate"
myX = c("loan_amnt", "longest_credit_length", "revol_util", "emp_length",
"home_ownership", "annual_inc", "purpose", "addr_state", "dti",
"delinq_2yrs", "total_acc", "verification_status", "term")
model <- h2o.gbm(x = myX, y = myY,
training_frame = train, validation_frame = valid,
score_each_iteration = T,
ntrees = 100, max_depth = 5, learn_rate = 0.05,
model_id = "InterestRateModel")
print(model)
# Download generated POJO for model
if (! file.exists("tmp")) {
dir.create("tmp")
}
h2o.download_pojo(model, path = "tmp")
library(h2o)
library(h2o)
library(h2o)
R
install.packages('statmod')
if ("package:h2o" %in% search()) { detach("package:h2o", unload=TRUE) }
if ("h2o" %in% rownames(installed.packages())) { remove.packages("h2o") }
if (! ("methods" %in% rownames(installed.packages()))) { install.packages("methods") }
if (! ("statmod" %in% rownames(installed.packages()))) { install.packages("statmod") }
if (! ("stats" %in% rownames(installed.packages()))) { install.packages("stats") }
if (! ("graphics" %in% rownames(installed.packages()))) { install.packages("graphics") }
if (! ("RCurl" %in% rownames(installed.packages()))) { install.packages("RCurl") }
if (! ("jsonlite" %in% rownames(installed.packages()))) { install.packages("jsonlite") }
if (! ("tools" %in% rownames(installed.packages()))) { install.packages("tools") }
if (! ("utils" %in% rownames(installed.packages()))) { install.packages("utils") }
# Now we download, install and initialize the H2O package for R.
install.packages("h2o", type="source", repos=(c("http://h2o-release.s3.amazonaws.com/h2o/rel-tibshirani/2/R")))
library(h2o)
library(statmod)
library(h2o)
setwd("/Users/X/git/coinrunDST_work_final/coinrun/result")
fnames <- list.files()
csv <- lapply(fnames, read.csv)
result <- do.call(rbind, csv)
data <- group_by(result, interval, currentweight)
library(dbplyr)
data <- group_by(result, interval, currentweight)
library(dplyr)
data <- group_by(result, interval, currentweight)
data <- group_by(result, inteval, currentweight)
plot=aggregate(. ~ inteval + currentweight, data = result, FUN = mean)
aggregate(. ~ inteval + currentweight, data = result, FUN = mean)
aggregate(. ~ inteval + currentweight, result, FUN = mean)
aaa=aggregate(. ~ inteval + currentweight, result, FUN = mean)[order(inteval),]
aaa
aaa<-aggregate(. ~ inteval + currentweight, result, FUN = mean)[order(inteval),]
aaa<-aggregate(. ~ inteval + currentweight, result, FUN = mean)
aaa[order(aaa$inteval), ]
library(ggplot2)
ggplot(aaa, aes(x=inteval, y=result, colour=currentweight)) + geom_point()+ ggtitle("steps")#以颜色区分
library(ggplot)
library(ggplot2)
ggplot(aaa, aes(x=inteval, y=result, colour=currentweight)) + geom_point()+ ggtitle("steps")#以颜色区分
ggplot(aaa, aes(x=inteval, y=result, colour=currentweight)) + geom_point()+ ggtitle("steps")
library(ggplot2)
ggplot(aaa, aes(x=inteval, y=result, colour=currentweight)) + geom_point()+ ggtitle("steps")
install.packages("ggplot2",dependencies=TRUE)
library(ggplot2)
install.packages("ggplot2", dependencies = TRUE)
library(ggplot2)
ggplot(aaa, aes(x=inteval, y=result, colour=currentweight)) + geom_point()+ ggtitle("steps")
ggplot2(aaa, aes(x=inteval, y=result, colour=currentweight)) + geom_point()+ ggtitle("steps")
ggplot(aaa, aes(x=inteval, y=result, colour=currentweight)) + geom_point()+ ggtitle("steps")
plot(aaa, aes(x=inteval, y=result, colour=currentweight)) + geom_point()+ ggtitle("steps")
library(ggplot2)
install.packages("ggplot2")
remove.packages("ggplot2movies", lib="~/Anaconda/anaconda3/lib/R/library")
install.packages("ggplot2")
install.packages('ggplot2')
ls -l /Library/Frameworks/R.framework/Versions/
